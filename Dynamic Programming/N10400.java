package uvastuff;

import java.util.Scanner;

public class N10400 {
    static int curOperIndex; // for keeping track of operator array's index
    static int answer; // the desired answer
    static char[] opers; // array of operators
    static int[] terms; // the terms given as input
    static int[][] memo; // memo table to keep track of already visited index/answer combinations
//    static int total; 
//    total was just used to keep track of # of calls made to dp(), to see effects of memoization
    
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int nC = sc.nextInt();
        for(int x=0; x<nC; x++){
//            total = 0;
            curOperIndex = 0;
            int nTerms = sc.nextInt();
            terms = new int[nTerms];
            opers = new char[nTerms-1];
            memo = new int[terms.length][100000];
            for(int i=0; i<terms.length; i++)
                for(int j=0; j<100000; j++)
                    memo[i][j] = -1;
            for(int i=0; i<nTerms; i++) terms[i] = sc.nextInt();
            answer = sc.nextInt();
            if(dp(0, terms[0])){
                for(int i=0; i<opers.length; i++)
                    System.out.print(terms[i]+""+opers[opers.length-1-i]); 
                    // necessary to print operators in reverse because they were stored last-first
                System.out.println(terms[terms.length-1]+"="+answer);
            }else System.out.println("NO EXPRESSION");
//            System.out.println(total);
        }
    }
    
/* 
    function description: 
    curVal contains the answer to some calculation made from the terms at index
    0 to the specified index. Now, using curVal with the remaining terms 
    (ie. the terms from index+1 up to the end of the array), can we generate the
    answer we need? Return true if yes, and false otherwise.
    
    how it works:
    Initially, the function will have index=0, meaning we've only used the first
    term, and therefore curVal=terms[0]. Next, we try to do any of the four
    operations with terms[1], and recursively call the function again, with the
    updated info.
    
    If we've reached the end of the array (index==terms.length-1), then that means
    we've already used up all the terms, and therefore curVal must have the final
    answer. So, if curVal==answer, we return true, otherwise we return false.
    
    According to the problem statement, no value in the calculation can go over
    32000 or go under -32000. So, if at any point curVal does either of those, 
    we return false. 
    
    Finally, the memo table keeps track of the visited index/curVal combinations
    done by the function. The +32000 was done because the values can range between
    -32000 and +32000, and we can't have negative indexes in the array, so "index"
    -32000 becomes index 0, index 0 becomes index 32000, and so on. The memo table
    can have three values: -1, 0, and 1. -1 means that the index/curVal combo has
    not been reached yet, and calculation can proceed as normal. 0 means that we've
    been here before, and we've already proven that an answer can no longer be reached
    from this point, so we return false. 1 means that we've already been here before,
    but this path is does lead to the answer. This memo table cuts down runtime significantly,
    as seen in the value of total with and without the memo table.
    
    parameter description:
    index- specifies which terms of the array we've already used and which ones we haven't
    curVal- the value generated by the terms we've already used
*/  
    static boolean dp(int index, int curVal){
//        total++;
        if(curVal>32000 || curVal<-32000) return false;
        if(memo[index][curVal+32000]!=-1){
            if(memo[index][curVal+32000]==0) return false;
            else return true;
        }
        if(index==terms.length-1){
            if(curVal==answer) return true;
            else return false;
        }else{
            // try to prove addition
            if(dp(index+1, curVal+terms[index+1])){
                opers[curOperIndex++] = '+';
                memo[index][curVal+32000] = 1;
                return true;
            }
            // try to prove subtraction
            else if(dp(index+1, curVal-terms[index+1])){
                opers[curOperIndex++] = '-';
                memo[index][curVal+32000] = 1;
                return true;
            }
            // try to prove multiplication
            else if(dp(index+1, curVal*terms[index+1])){
                opers[curOperIndex++] = '*';
                memo[index][curVal+32000] = 1;
                return true;
            }
            // try to prove division
            else if(curVal%terms[index+1]==0 && dp(index+1, curVal/terms[index+1])){
                opers[curOperIndex++] = '/';
                memo[index][curVal+32000] = 1;
                return true;
            }
            // we failed to prove all four operations, therefore an answer can no longer
            // be generated from this point, and we return false.
            memo[index][curVal+32000] = 0;
            return false;
        }
    }
}
